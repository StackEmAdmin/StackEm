/**
 * Generates a list of actions based on the given key input and keybinds.
 *
 * @param {string} key - The key input by the user.
 * @param {Array} actionsQ - The queue of current actions.
 * @param {Object} keybinds - An object mapping commands to their respective keybinds.
 * @param {number} DAS - The Delayed Auto Shift value for determining action timing.
 * @param {number} ARR - The Auto Repeat Rate value for determining repeat action timing.
 * @param {number} SRR - The Soft Drop Repeat Rate value for soft drop actions.
 * @param {number} currentTime - The current time in milliseconds.
 *
 * @returns {Array} An array of action objects with their corresponding timing and properties.
 */
function actionsFromKey(key, actionsQ, keybinds, DAS, ARR, SRR, currentTime) {
  const actions = [];
  for (const command in keybinds) {
    if (!keybinds[command].includes(key)) {
      continue;
    }
    if (command === 'left') {
      actions.push({ time: currentTime, action: command });
      actions.push({
        time: currentTime + DAS,
        action: 'ARRLeft',
        delay: ARR,
        count: 0,
      });
      stopRepeatAction(actionsQ, 'ARRRight', currentTime);
    } else if (command === 'right') {
      actions.push({ time: currentTime, action: command });
      actions.push({
        time: currentTime + DAS,
        action: 'ARRRight',
        delay: ARR,
        count: 0,
      });
      stopRepeatAction(actionsQ, 'ARRLeft', currentTime);
    } else if (command === 'softDrop') {
      actions.push({
        time: currentTime,
        action: 'SRRDown',
        delay: SRR,
        count: 0,
      });
    } else {
      actions.push({ time: currentTime, action: command });
    }
  }
  return actions;
}

/**
 * Checks if the given key is the last key in the given modifier keybind and that all keys
 * in the keybind are pressed in order.
 *
 * @param {string} key - The key to check.
 * @param {Object} pressed - The pressed object containing the current key state.
 * @param {number} currentTime - The current time in milliseconds.
 * @param {Array} modKeyBind - The modifier keybind array.
 * @returns {boolean} True if the key is the last key in the keybind and all keys are pressed
 *   in order, false otherwise.
 */
function validModAction(key, pressed, currentTime, modKeyBind) {
  const lastVal = (arr, offSet = 0) => arr[arr.length - 1 - offSet];

  // Check key is pressed
  if (lastVal(modKeyBind) !== key) {
    return false;
  }

  // Check prev key held (if there is one)
  let offSet = 1;
  let prevKey = lastVal(modKeyBind, offSet);
  let start = currentTime;
  while (prevKey) {
    const prevKeyTime = lastVal(pressed.current[prevKey].down);
    if (!pressed.current[prevKey].active || prevKeyTime > start) {
      return false;
    }
    offSet += 1;
    prevKey = lastVal(modKeyBind, offSet);
    start = prevKeyTime;
  }

  return true;
}

/**
 * Checks if a given key is a modifier key and returns the corresponding modifier action.
 *
 * @param {string} key - The key to check.
 * @param {Object} pressed - The pressed object containing the current key state.
 * @param {Object} modKeybinds - A map of modifier command to the keybind array.
 * @param {boolean} modEnabled - If true, the modifier keybinds are enabled.
 * @param {number} currentTime - The current time in milliseconds.
 * @returns {Object[]} An array of modifier actions with the given time and command.
 *   If the modifier keybinds are not enabled or the key is not a modifier key, an empty
 *   array is returned.
 */
function modActionFromKey(key, pressed, modKeybinds, modEnabled, currentTime) {
  if (!modEnabled) {
    return [];
  }

  for (const command in modKeybinds) {
    if (command === 'modifier') {
      continue;
    }
    if (validModAction(key, pressed, currentTime, modKeybinds[command])) {
      return [{ time: currentTime, action: command, isMod: true }];
    }
  }

  return [];
}

/**
 * Determines whether the current actions queue includes any game flow actions.
 *
 * Game flow actions are defined as actions that affect the game state by undoing
 * or redoing moves. This function checks if any such actions exist within the
 * provided actions array.
 *
 * @param {Array} actions - The array of actions to be checked.
 * @returns {boolean} - True if any game flow action exists, otherwise false.
 */
function gameFlowAction(actions) {
  return actions.some((a) => {
    return (
      a.action === 'undoMove' ||
      a.action === 'undo' ||
      a.action === 'redoMove' ||
      a.action === 'redo'
    );
  });
}

/**
 * Converts a key press into an array of actions to be added to the current actions queue.
 *
 * If the key is a modifier key, the function will return an array containing the
 * corresponding modifier action. If the key is not a modifier key, the function will
 * return an array of actions generated by the actionsFromKey function.
 *
 * @param {Object} pressed - The pressed object containing the current key state.
 * @param {string} key - The key that was pressed.
 * @param {Array} actionsQ - The current actions queue.
 * @param {Object} keybinds - A map of command to the keybind array.
 * @param {Object} modKeybinds - A map of modifier command to the keybind array.
 * @param {boolean} modEnabled - If true, the modifier keybinds are enabled.
 * @param {number} DAS - The delay after key press before repeat action is enabled.
 * @param {number} ARR - The delay between each repeat action.
 * @param {number} SRR - The delay between each soft drop.
 * @param {number} currentTime - The time at which the key was pressed.
 * @returns {Array} An array of actions to be added to the current actions queue.
 */
function getActions(
  pressed,
  key,
  actionsQ,
  keybinds,
  modKeybinds,
  modEnabled,
  DAS,
  ARR,
  SRR,
  currentTime
) {
  // Don't add actions if undoing or redoing
  if (gameFlowAction(actionsQ.current)) {
    return [];
  }

  const modActions = modActionFromKey(
    key,
    pressed,
    modKeybinds,
    modEnabled,
    currentTime
  );

  // Prevent modifier actions from interfering with actions
  if (modActions.length > 0) {
    return modActions;
  }

  const actions = actionsFromKey(
    key,
    actionsQ,
    keybinds,
    DAS,
    ARR,
    SRR,
    currentTime
  );

  return actions;
}

/**
 * Checks if the given key is pressed and active.
 *
 * @param {Object} pressed - The pressed object containing the current key state.
 * @param {string} key - The key to check.
 * @returns {boolean} True if the key is pressed and active, false otherwise.
 */
function pressedActive(pressed, key) {
  return key !== '' && pressed.current[key].active;
}

/**
 * Checks if all keys in the given keybind array are pressed in order based on time.
 *
 * @param {Object} pressed - The pressed object containing the current key state.
 * @param {Array.<String>} keys - The array of keys to check.
 * @returns {boolean} True if all keys are pressed in order, false otherwise.
 */
function pressedInOrder(pressed, keys) {
  const lastVal = (arr, offSet = 0) => arr[arr.length - 1 - offSet];
  // Checks keys are active and pressed in order based on time

  let offSet = 0;
  let prevKey = lastVal(keys, offSet);
  let start = Infinity;
  while (prevKey) {
    const prevKeyTime = lastVal(pressed.current[prevKey].down);
    if (!pressed.current[prevKey].active || prevKeyTime > start) {
      return false;
    }
    offSet += 1;
    prevKey = lastVal(keys, offSet);
    start = prevKeyTime;
  }
  return true;
}

/**
 * Removes the given repeat action from the given actions queue.
 *
 * This function also adds a stop context to the repeat action if it needs to
 * be applied in the next frame. This is done by adding a stopTime property to
 * the action object.
 *
 * @param {Object} actions - The actions object containing the current queue of
 *   actions.
 * @param {string} action - The name of the repeat action to remove.
 * @param {number} currentTime - The current time in milliseconds.
 */
function stopRepeatAction(actions, action, currentTime) {
  actions.current = actions.current.filter((a) => {
    // Keep other actions (or keep if stopped)
    if (a.action !== action || a.stopTime) {
      return true;
    }
    if (a.time + a.count * a.delay <= currentTime) {
      a.stopTime = currentTime;
      return true;
    }
    return false;
  });
}

/**
 * Resumes a repeat action by adding it to the actions queue if not already active.
 *
 * This function checks if a repeat action with the specified action name is
 * active (i.e., without a stop time) in the current actions queue. If it is not
 * active, it adds a new repeat action to the queue with the given offset, delay,
 * and current time.
 *
 * @param {Object} actions - The actions object containing the current queue of actions.
 * @param {string} action - The name of the repeat action to resume.
 * @param {number} offSet - The offset time to apply before the action is executed.
 * @param {number} delay - The delay between each repeat of the action.
 * @param {number} currentTime - The current time in milliseconds.
 */
function resumeRepeatAction(actions, action, offSet, delay, currentTime) {
  if (actions.current.some((a) => a.action === action && !a.stopTime)) {
    return;
  }
  actions.current.push({
    time: currentTime + offSet,
    action: action,
    delay: delay,
    count: 0,
  });
}

/**
 * Calculates the remaining time until the next Delayed Auto Shift (DAS) action
 * should be triggered.
 *
 * @param {Object} pressed - The pressed object containing the current key state.
 * @param {string} key - The key that was pressed to trigger the DAS action.
 * @param {number} DAS - The delay after key press before repeat action is enabled.
 * @param {number} currentTime - The current time in milliseconds.
 *
 * @returns {number} The remaining time until the next DAS action should be
 *   triggered.
 */
function remainingDAS(pressed, key, DAS, currentTime) {
  const pressedTime =
    pressed.current[key].down[pressed.current[key].down.length - 1];
  return DAS - Math.min(DAS, currentTime - pressedTime);
}

/**
 * Switches a repeat action from one action to another within the current actions queue.
 *
 * This function stops a specified repeat action and, if the relevant key is still
 * pressed, resumes a new repeat action. It calculates the appropriate offset for
 * the new repeat action based on the remaining Delayed Auto Shift (DAS) time.
 *
 * @param {Object} actionsQ - The actions object containing the current queue of actions.
 * @param {Object} pressed - A map of keys to their respective state.
 * @param {string} from - The name of the repeat action to stop.
 * @param {string} to - The name of the new repeat action to resume.
 * @param {Object} keybinds - A map of action to the keys that activate it.
 * @param {string} command - The command associated with the keybind.
 * @param {number} DAS - The delay after key press before repeat action is enabled.
 * @param {number} delay - The delay between each repeat of the new action.
 * @param {number} currentTime - The current time in milliseconds.
 */
function switchRepeatAction(
  actionsQ,
  pressed,
  from,
  to,
  keybinds,
  command,
  DAS,
  delay,
  currentTime
) {
  stopRepeatAction(actionsQ, from, currentTime);
  if (pressedActive(pressed, keybinds[command])) {
    const offSet = remainingDAS(pressed, keybinds[command], DAS, currentTime);
    resumeRepeatAction(actionsQ, to, offSet, delay, currentTime);
  }
}

/**
 * Applies actions when a key is released.
 *
 * This function stops the ARRLeft/ARRRight repeat actions when the left or right
 * key is released. It also stops the SRRDown repeat action when the soft drop
 * key is released.
 *
 * @param {Object} actionsQ - The actions object containing the current queue of actions.
 * @param {Object} pressed - A map of keys to their respective state.
 * @param {string} command - The command associated with the keybind.
 * @param {Object} keybinds - A map of action to the keys that activate it.
 * @param {number} DAS - The delay after key press before repeat action is enabled.
 * @param {number} ARR - The delay between each repeat action.
 * @param {number} currentTime - The current time in milliseconds.
 */
function applyReleaseAction(
  actionsQ,
  pressed,
  command,
  keybinds,
  DAS,
  ARR,
  currentTime
) {
  if (command === 'left') {
    // Stop repeat action ARRLeft and resume ARRRight (when pressed)
    switchRepeatAction(
      actionsQ,
      pressed,
      'ARRLeft',
      'ARRRight',
      keybinds,
      'right',
      DAS,
      ARR,
      currentTime
    );
  }

  if (command === 'right') {
    switchRepeatAction(
      actionsQ,
      pressed,
      'ARRRight',
      'ARRLeft',
      keybinds,
      'left',
      DAS,
      ARR,
      currentTime
    );
  }

  if (command === 'softDrop') {
    stopRepeatAction(actionsQ, 'SRRDown', currentTime);
  }
}

/**
 * Applies the release action to the given modifier action by adding a stop time
 * to the action if it is in the current actions queue.
 *
 * @param {Object} actionsQ - The actions queue.
 * @param {string} action - The name of the modifier action to apply.
 * @param {number} currentTime - The time at which the action is being released.
 */
function applyReleaseModAction(actionsQ, action, currentTime) {
  actionsQ.current = actionsQ.current.map((a) => {
    if (a.action === action && !a.stopTime) {
      a.stopTime = currentTime;
    }
    return a;
  });
}

/**
 * Applies release actions when a key is released.
 *
 * This function stops the ARRLeft/ARRRight repeat actions when the left or right
 * key is released. It also stops the SRRDown repeat action when the soft drop
 * key is released. Additionally, it adds a stop time to the modifier actions if
 * they are in the current actions queue and the key is a modifier key.
 *
 * @param {Object} actionsQ - The actions object containing the current queue of actions.
 * @param {Object} pressed - A map of keys to their respective state.
 * @param {string} key - The key that was released.
 * @param {Object} keybinds - A map of action to the keys that activate it.
 * @param {Object} modKeybinds - A map of modifier command to the keybind array.
 * @param {number} DAS - The delay after key press before repeat action is enabled.
 * @param {number} ARR - The delay between each repeat action.
 * @param {number} SRR - The delay between each soft drop.
 * @param {number} currentTime - The time at which the key was released.
 */
function applyReleaseActions(
  actionsQ,
  pressed,
  key,
  keybinds,
  modKeybinds,
  DAS,
  ARR,
  SRR,
  currentTime
) {
  for (const command in keybinds) {
    if (keybinds[command].includes(key)) {
      applyReleaseAction(
        actionsQ,
        pressed,
        command,
        keybinds,
        DAS,
        ARR,
        currentTime
      );
    }
  }

  // Only apply release modifier actions to undo/redo actions
  if (!gameFlowAction(actionsQ.current)) {
    return;
  }

  for (const action in modKeybinds) {
    if (modKeybinds[action].includes(key)) {
      applyReleaseModAction(
        actionsQ,
        pressed,
        action,
        modKeybinds,
        currentTime
      );
    }
  }
}

/**
 * Creates an action to fill a cell or an entire row based on the modifier key state.
 *
 * If the modifier key is pressed, the action will be to fill the entire row.
 * Otherwise, it will create an action to fill a single cell at the specified row and column.
 *
 * @param {Object} pressed - The pressed object containing the current key state.
 * @param {Object} modKeybinds - A map of modifier command to the keybind array.
 * @param {boolean} modEnabled - Whether the modifier keybinds are enabled.
 * @param {number} row - The row index of the cell to be filled.
 * @param {number} col - The column index of the cell to be filled.
 * @param {number} currentTime - The time at which the action is being enqueued.
 * @returns {Object} An action to be added to the current actions queue.
 */
function fillCellAction(
  pressed,
  modKeybinds,
  modEnabled,
  row,
  col,
  currentTime
) {
  if (!modEnabled) {
    return null;
  }

  if (pressedInOrder(pressed, modKeybinds['modifier'])) {
    return {
      time: currentTime,
      action: 'fillRow',
      row: row,
      col: col,
      isMod: true,
    };
  }
  return {
    time: currentTime,
    action: 'fillCell',
    row: row,
    col: col,
    isMod: true,
  };
}

/**
 * Resets the auto-color feature by adding a resetFillCell action to the current
 * actions queue.
 *
 * @param {boolean} modEnabled - Whether the modifier keybinds are enabled.
 * @param {number} currentTime - The time at which the action is being enqueued.
 * @returns {Object} An action to be added to the current actions queue.
 */
function resetFillCellAction(modEnabled, currentTime) {
  if (!modEnabled) {
    return null;
  }
  return {
    time: currentTime,
    action: 'resetFillCell',
    isMod: true,
  };
}

/**
 * Creates an action to clear a cell or an entire row based on the modifier key state.
 *
 * If the modifier key is pressed in order, the action will be to clear the entire row.
 * Otherwise, it will create an action to clear a single cell at the specified row and column.
 *
 * @param {Object} pressed - The pressed object containing the current key state.
 * @param {Object} modKeybinds - A map of modifier command to the keybind array.
 * @param {boolean} modEnabled - Whether the modifier keybinds are enabled.
 * @param {number} row - The row index of the cell to be cleared.
 * @param {number} col - The column index of the cell to be cleared.
 * @param {number} currentTime - The time at which the action is being enqueued.
 * @returns {Object} An action object to be added to the current actions queue.
 */
function clearCellAction(
  pressed,
  modKeybinds,
  modEnabled,
  row,
  col,
  currentTime
) {
  if (!modEnabled) {
    return null;
  }
  if (pressedInOrder(pressed, modKeybinds['modifier'])) {
    return {
      time: currentTime,
      action: 'clearRow',
      row: row,
      col: col,
      isMod: true,
    };
  }
  return {
    time: currentTime,
    action: 'clearCell',
    row: row,
    col: col,
    isMod: true,
  };
}

export {
  getActions,
  applyReleaseActions,
  fillCellAction,
  resetFillCellAction,
  clearCellAction,
};
